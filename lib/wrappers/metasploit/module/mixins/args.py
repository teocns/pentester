import pymetasploit3.msfrpc


class UndefinedModuleArgumentException(Exception):
    def __init__(self, *args: object) -> None:
        super().__init__(*args)

class ForbiddenOptionException(Exception):
    def __init__(self, *args: object) -> None:
        super().__init__(*args)



class ArgsMixin(pymetasploit3.msfrpc.MsfModule):

    @property
    def missing_required(self):
        return super().missing_required

    class ALIASES:
        host = {"RHOST", "RHOSTS", "HOSTNAME", "HOST"}


        @classmethod
        def iter(self, property_name = None):
            for key, aliases in self.__dict__.items():
                if property_name is not None and property_name != key:
                    continue
                if key.startswith('_') or not isinstance(aliases, set):
                    continue
                for alias in aliases:
                    yield key, alias

            
        @classmethod
        def find(cls,arg):
            """
            Iterate the container aliases set of an option
            """
            for prop, aliases in cls.iter():
                if arg in aliases:
                    for item in getattr(cls.ALIASES, prop):
                        yield prop, item

    @property
    def codename(self):
        return self.fullname
        
    fullname: str

    
    description: str
    

    @property
    def host(self):
        for opt in self.options:
            for alias in self.ALIASES.host:
                if alias == opt:
                    return opt
            

    @host.setter
    def host(self,value):
        # Find the option based on __ALIASES__
        for option in self.ALIASES.host:
            if option in self.options:
                self.options[option] = value


    @classmethod
    def option_isset(cls,option):
        return option in cls.runoptions
    

    def set_option(self, name, value):
        if name not in self.options:
            raise ForbiddenOptionException(name, self.codename)
        if name in self.runoptions:
            log.warning("Overriding option {} with {}".format(name, value))
        
        self.runoptions[name] = value


    def find_property(alias):
        """
        Based on an alias (like RHOST, HOSTNAME), it will return a property
        """
        pass


    def prepare(self, **params):
        # Itereate all the options and attempt to retrieve aliases
        
        for prop, value in params.items():
            #for _, alias in self.ALIASES.iter(prop):
                # Before setting the actual option, make sure we really want to set it
            correspondences = [_alias for _, _alias in self.ALIASES.iter(prop) if _alias in self.missing_required]
            option_alias = correspondences[0] if correspondences else None
            
            if not option_alias:
                log.warning("[{}] Could not find alias option to set arg {}:{}".format(
                    self.codename, prop, value
                ))
                continue
        
            self.set_option(option_alias, value)    
            

            


        # Raise if there are missing args
        for missing_arg in self.missing_required: 
            raise UndefinedModuleArgumentException(missing_arg, self.codename)


        if DEBUG:
            self.set_option('VERBOSE',True)



from config import DEBUG

import logging
log = logging.getLogger(__name__)