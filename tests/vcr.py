import json
import inspect
import re
import email.utils
from vcr import VCR
from config import BASE_DIR, CI
from io import BytesIO



def cassette_dir():
    '''Use a global location for cassettes'''
    return f'{BASE_DIR}/tests/vcr_cassettes/'


def _vcr_basic_auth_matcher(r1, r2):
    assert (
        r1.headers['Authorization'] == r2.headers['Authorization']
    ), f'Authorization headers do not match {r1.headers["Authorization"]} != {r2.headers["Authorization"]}'


# Based on: https://stackoverflow.com/a/10756615/114132
def nested_dict_iter(nested, mapper, last_key=None):
    '''Iterate over all key/value pairs in a dict and descend into all nested dicts.'''
    if isinstance(nested, dict):
        out = {}
        for key, value in nested.items():
            out[key] = nested_dict_iter(value, mapper, key)
        return out

    if isinstance(nested, list):
        return [nested_dict_iter(el, mapper, last_key) for el in nested]

    if not last_key:
        return nested

    return mapper(last_key, nested)


def config_vcr(
    cassette_path=None, record_mode=None, deep_filter=[], before_record_request=None,
):
    if not record_mode:
        record_mode = 'none' if settings.CI else 'once'

    if deep_filter and before_record_request:
        raise Exception("Can't use deep_filter when overriding before_record_request")

    def before_record_cb(request):
        # Conditions based on:
        # https://github.com/kevin1024/vcrpy/blob/c79a06f639dd628536c9868044e78df1012985f9/vcr/filters.py#L86-L88
        if (
            request.method == "POST"
            and not isinstance(request.body, BytesIO)
            and request.headers.get("Content-Type") == "application/json"
            and deep_filter
        ):
            json_data = json.loads(request.body.decode("utf-8"))
            sanitized_data = nested_dict_iter(
                json_data, lambda k, v: '**hidden**' if k in deep_filter else v
            )
            request.body = json.dumps(sanitized_data).encode("utf-8")

        return request

    if not before_record_request:
        before_record_request = before_record_cb

    
    if cassette_path:
        config = VCR(
            cassette_library_dir=(cassette_dir() + cassette_path),
            decode_compressed_response=True,
            record_mode=record_mode,
            before_record_request=before_record_request,
        )

    else:
        raise Exception("Must specify VCR cassette patH")

    config.register_matcher('basic_auth', _vcr_basic_auth_matcher)
    return config


def use_vcr_cassette(
    *args,
    extra_matchers=[],
    record_mode=None,
    allow_playback_repeats=False,
    use_gcs_persister=False,
    deep_filter=[],
    pass_request_stamp=False,
    before_record_request=None,
    **kwargs,
):
    '''Decorator for using VCR on a test.

    There are two modes - locally persisted, and GCS persisted.

    In local storage usage, we need a path, but when using GCS we only need the
    filename. Use this to determine which persister we should use.

    i.e. to use local filesystem storage
        @use_vcr_cassette(CASSETTE_DIR, 'credit_payment.yml')
    to use GCS
        @use_vcr_cassette("unit_tests/payments/credit_payment.yml')

    Since we can infer the filename from the method running the test, you can leave it
    empty to generate a path that is built from the method and the test name. Only use
    this if you're happy having a separate cassette for each test. E.g. this test:
      file: server/tests/foo/bar.py
      @use_vcr_cassette
      def test_works():

    Will auto-create a cassette for the path 'foo/bar/test_works.yaml'. i.e. it is the
    equivalent of:
      @use_vcr_cassette('foo/bar/test_works.yaml')
      def test_works():


    Other arguments:

      deep_filter: VCR's inbuilt filter_post_data_parameters only filters out top-level
          keys in the body. Use `deep_filter=['password']` to filter out any fields
          matching `password` in the entire body from the saved cassette.

      pass_request_stamp: if your test relies on the exact time the request was made,
          you may want to freeze time to the same time as the request time. This is easy
          if you're actually making the request - it's now - but on an existing /
          replayed request you need to find the time the request was made. Set
          `pass_request_stamp=True` to pass the stamp of the requests made to the
          function in the `request_stamp` kwarg.

          Note that if there are multiple requests, they may have different stamps.
          Currently we take the max. If you need stamps separated, break into separate
          functions.
    '''

    def decorator(function):
        if len(args) == 0:
            cassette_path = None
            module = re.match(
                rf'^{BASE_DIR}/tests/(.*)\.py', inspect.getfile(function)
            )[1]
            cassette_filename = f'{module}/{function.__name__}.yaml'
        elif len(args) == 1:
            cassette_path = None
            cassette_filename = args[0]
        else:
            cassette_path, cassette_filename = args

        if not cassette_filename:
            raise Exception('Cassette filename required')

        def wrapper(*args, **kwargs):
            
            vcr = config_vcr(
                cassette_path=cassette_path,
                record_mode=record_mode,
                deep_filter=deep_filter,
                before_record_request=before_record_request,
            )

            if extra_matchers:
                vcr.match_on = (*vcr.match_on, *extra_matchers)

            with vcr.use_cassette(
                cassette_filename,
                allow_playback_repeats=allow_playback_repeats,
                **kwargs,
            ) as cassette:
                if pass_request_stamp:
                    stamps = [
                        email.utils.parsedate_to_datetime(r['headers']['Date'][0])
                        for r in cassette.responses
                    ]
                    kwargs['request_stamp'] = stamps and max(stamps) or utc_now()

                return function(*args, **kwargs)

        return wrapper

    return decorator
